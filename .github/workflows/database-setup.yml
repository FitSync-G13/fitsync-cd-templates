name: Database Setup (PostgreSQL + Redis + TLS)

on:
  workflow_call:
    inputs:
      cluster_name:
        description: 'K3s cluster name'
        required: true
        type: string
      environment:
        description: 'GitHub environment name'
        required: true
        type: string
      postgres_version:
        description: 'PostgreSQL version'
        required: false
        type: string
        default: '15'
      redis_version:
        description: 'Redis version'
        required: false
        type: string
        default: '7'
    secrets:
      AWS_ROLE_ARN:
        required: true
      CLOUDFLARE_API_TOKEN:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  setup-database:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ vars.AWS_REGION }}
        role-session-name: GitHubActions-Database-Setup

    - name: Get database instance
      id: get-db
      run: |
        echo "Getting database instance for ${{ inputs.cluster_name }}"
        
        DB_INSTANCE_ID=$(aws ec2 describe-instances \
          --filters \
            "Name=tag:Project,Values=${{ vars.PROJECT_NAME }}" \
            "Name=tag:Role,Values=db" \
            "Name=tag:Env,Values=${{ vars.SPOKE_ENV }}" \
            "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        
        if [ "$DB_INSTANCE_ID" == "None" ] || [ -z "$DB_INSTANCE_ID" ]; then
          echo "Error: No database instance found"
          exit 1
        fi
        
        echo "instance_id=$DB_INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "Database Instance: $DB_INSTANCE_ID"

    - name: Install PostgreSQL ${{ inputs.postgres_version }}
      run: |
        echo "Installing PostgreSQL ${{ inputs.postgres_version }}..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "if dpkg -l | grep -q postgresql-${{ inputs.postgres_version }}; then echo \"PostgreSQL already installed\"; exit 0; fi",
            "apt update",
            "apt install -y wget ca-certificates",
            "wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add -",
            "echo \"deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\" > /etc/apt/sources.list.d/pgdg.list",
            "apt update",
            "apt install -y postgresql-${{ inputs.postgres_version }} postgresql-contrib-${{ inputs.postgres_version }}",
            "systemctl enable postgresql",
            "systemctl start postgresql"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        echo "Waiting for PostgreSQL installation..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.get-db.outputs.instance_id }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" == "Success" ]; then
            echo "PostgreSQL installed"
            break
          elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
            echo "PostgreSQL installation failed"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
          
          echo "Status: $STATUS ($i/60)"
          sleep 5
        done

    - name: Configure PostgreSQL
      run: |
        echo "Configuring PostgreSQL..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "grep -q \"listen_addresses = .*\\*\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf || sed -i \"s/#listen_addresses = '\''localhost'\''/listen_addresses = '\''*'\''/\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf",
            "grep -q \"host all all 10.0.0.0/8\" /etc/postgresql/${{ inputs.postgres_version }}/main/pg_hba.conf || echo \"host all all 10.0.0.0/8 scram-sha-256\" >> /etc/postgresql/${{ inputs.postgres_version }}/main/pg_hba.conf",
            "systemctl restart postgresql"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "PostgreSQL configured"

    - name: Install Redis ${{ inputs.redis_version }}
      run: |
        echo "Installing Redis ${{ inputs.redis_version }}..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "if systemctl is-active --quiet redis-server; then echo \"Redis already installed\"; exit 0; fi",
            "apt install -y lsb-release curl gpg",
            "curl -fsSL https://packages.redis.io/gpg | gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg",
            "echo \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | tee /etc/apt/sources.list.d/redis.list",
            "apt update",
            "apt install -y redis-server",
            "systemctl enable redis-server",
            "systemctl start redis-server"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        echo "Waiting for Redis installation..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.get-db.outputs.instance_id }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" == "Success" ]; then
            echo "Redis installed"
            break
          elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
            echo "Redis installation failed"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
          
          echo "Status: $STATUS ($i/60)"
          sleep 5
        done

    - name: Configure Redis
      run: |
        echo "Configuring Redis..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "grep -q \"^bind 0.0.0.0\" /etc/redis/redis.conf || sed -i \"s/^bind 127.0.0.1 -::1/bind 0.0.0.0/\" /etc/redis/redis.conf",
            "grep -q \"^protected-mode no\" /etc/redis/redis.conf || sed -i \"s/^protected-mode yes/protected-mode no/\" /etc/redis/redis.conf",
            "systemctl restart redis-server"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "Redis configured"

    - name: Install Certbot
      run: |
        echo "Installing Certbot..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "if command -v certbot &> /dev/null; then echo \"Certbot already installed\"; exit 0; fi",
            "apt install -y certbot python3-certbot-dns-cloudflare"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "Certbot installed"

    - name: Obtain TLS certificate
      run: |
        echo "Obtaining TLS certificate for ${{ vars.DB_PRIVATE_DNS }}..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands='[
            "if [ -d /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }} ]; then echo \"Certificate exists\"; exit 0; fi",
            "mkdir -p /root/.secrets",
            "echo \"dns_cloudflare_email = ${{ vars.CERT_EMAIL }}\" > /root/.secrets/cloudflare.ini",
            "echo \"dns_cloudflare_api_key = ${{ secrets.CLOUDFLARE_API_TOKEN }}\" >> /root/.secrets/cloudflare.ini",
            "chmod 600 /root/.secrets/cloudflare.ini",
            "certbot certonly --dns-cloudflare --dns-cloudflare-credentials /root/.secrets/cloudflare.ini -d ${{ vars.DB_PRIVATE_DNS }} --non-interactive --agree-tos --email ${{ vars.CERT_EMAIL }} --dns-cloudflare-propagation-seconds 30"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        echo "Waiting for certificate..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.get-db.outputs.instance_id }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" == "Success" ]; then
            echo "Certificate obtained"
            break
          elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
            echo "Certificate acquisition failed"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
          
          echo "Status: $STATUS ($i/60)"
          sleep 5
        done

    - name: Configure PostgreSQL TLS
      run: |
        echo "Configuring PostgreSQL TLS..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands="[
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/fullchain.pem /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.crt\",
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/privkey.pem /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key\",
            \"chown postgres:postgres /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.*\",
            \"chmod 600 /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key\",
            \"grep -q '^ssl = on' /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf || sed -i 's/#ssl = off/ssl = on/' /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf\",
            \"grep -q \\\"ssl_cert_file = '/var/lib/postgresql/${{ inputs.postgres_version }}/main/server.crt'\\\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf || sed -i \\\"s|#ssl_cert_file = 'server.crt'|ssl_cert_file = '/var/lib/postgresql/${{ inputs.postgres_version }}/main/server.crt'|\\\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf\",
            \"grep -q \\\"ssl_key_file = '/var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key'\\\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf || sed -i \\\"s|#ssl_key_file = 'server.key'|ssl_key_file = '/var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key'|\\\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf\",
            \"systemctl restart postgresql\"
          ]" \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "PostgreSQL TLS configured"

    - name: Configure Redis TLS
      run: |
        echo "Configuring Redis TLS..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands="[
            \"mkdir -p /etc/redis/certs\",
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/fullchain.pem /etc/redis/certs/server.crt\",
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/privkey.pem /etc/redis/certs/server.key\",
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/chain.pem /etc/redis/certs/ca.crt\",
            \"chown redis:redis /etc/redis/certs/*\",
            \"chmod 600 /etc/redis/certs/server.key\",
            \"grep -q '^port 0' /etc/redis/redis.conf || sed -i 's/^port 6379/port 0/' /etc/redis/redis.conf\",
            \"grep -q '^tls-port' /etc/redis/redis.conf || echo 'tls-port 6379' >> /etc/redis/redis.conf\",
            \"grep -q '^tls-cert-file' /etc/redis/redis.conf || echo 'tls-cert-file /etc/redis/certs/server.crt' >> /etc/redis/redis.conf\",
            \"grep -q '^tls-key-file' /etc/redis/redis.conf || echo 'tls-key-file /etc/redis/certs/server.key' >> /etc/redis/redis.conf\",
            \"grep -q '^tls-ca-cert-file' /etc/redis/redis.conf || echo 'tls-ca-cert-file /etc/redis/certs/ca.crt' >> /etc/redis/redis.conf\",
            \"grep -q '^tls-auth-clients no' /etc/redis/redis.conf || echo 'tls-auth-clients no' >> /etc/redis/redis.conf\",
            \"systemctl restart redis-server\"
          ]" \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "Redis TLS configured"

    - name: Setup certificate auto-renewal
      run: |
        echo "Setting up auto-renewal..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands="[
            \"mkdir -p /etc/letsencrypt/renewal-hooks/deploy\",
            \"if [ -f /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh ]; then exit 0; fi\",
            \"echo '#!/bin/bash' > /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/fullchain.pem /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.crt' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/privkey.pem /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'chown postgres:postgres /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.*' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'chmod 600 /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/fullchain.pem /etc/redis/certs/server.crt' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/privkey.pem /etc/redis/certs/server.key' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/chain.pem /etc/redis/certs/ca.crt' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'chown redis:redis /etc/redis/certs/*' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'chmod 600 /etc/redis/certs/server.key' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'systemctl restart postgresql' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'systemctl restart redis-server' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"chmod +x /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\"
          ]" \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "Auto-renewal configured"

    - name: Verify PostgreSQL
      run: |
        echo "Verifying PostgreSQL..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "systemctl status postgresql --no-pager || true",
            "sudo -u postgres psql -c \"SELECT version();\" || true",
            "sudo -u postgres psql -c \"SHOW ssl;\" || true"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }} || true
        
        aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.get-db.outputs.instance_id }} \
          --query 'StandardOutputContent' \
          --output text || echo "Could not retrieve output"

    - name: Verify Redis
      run: |
        echo "Verifying Redis..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "systemctl status redis-server --no-pager || true",
            "redis-cli --tls --cert /etc/redis/certs/server.crt --key /etc/redis/certs/server.key --cacert /etc/redis/certs/ca.crt ping || true"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }} || true
        
        aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.get-db.outputs.instance_id }} \
          --query 'StandardOutputContent' \
          --output text || echo "Could not retrieve output"

    - name: Test database connectivity
      run: |
        echo "Testing connectivity..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands="[
            \"apt install -y netcat-openbsd || true\",
            \"nc -zv localhost 5432 || echo 'PostgreSQL port check failed'\",
            \"nc -zv localhost 6379 || echo 'Redis port check failed'\",
            \"ss -tlnp | grep -E ':(5432|6379)' || true\",
            \"sudo -u postgres psql -c 'SELECT 1;' || echo 'PostgreSQL query failed'\",
            \"redis-cli --tls --cert /etc/redis/certs/server.crt --key /etc/redis/certs/server.key --cacert /etc/redis/certs/ca.crt SET test_key test_value || echo 'Redis SET failed'\",
            \"redis-cli --tls --cert /etc/redis/certs/server.crt --key /etc/redis/certs/server.key --cacert /etc/redis/certs/ca.crt GET test_key || echo 'Redis GET failed'\"
          ]" \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }} || true
        
        echo "Connectivity test output:"
        aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.get-db.outputs.instance_id }} \
          --query 'StandardOutputContent' \
          --output text || echo "Could not retrieve output"

    - name: Summary
      run: |
        echo "=========================================="
        echo "Database Setup Complete!"
        echo "=========================================="
        echo "PostgreSQL: ${{ inputs.postgres_version }}"
        echo "Redis: ${{ inputs.redis_version }}"
        echo "Database DNS: ${{ vars.DB_PRIVATE_DNS }}"
        echo "TLS: Enabled"
        echo "=========================================="
        echo "Connection strings:"
        echo "PostgreSQL: postgresql://user:password@${{ vars.DB_PRIVATE_DNS }}:5432/dbname?sslmode=require"
        echo "Redis: redis://${{ vars.DB_PRIVATE_DNS }}:6379?tls=true"
        echo "=========================================="
