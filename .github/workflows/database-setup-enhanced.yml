name: Enhanced Database Setup (PostgreSQL + Redis + Multi-DB + Secrets)

on:
  workflow_call:
    inputs:
      cluster_name:
        description: 'K3s cluster name'
        required: true
        type: string
      environment:
        description: 'GitHub environment name'
        required: true
        type: string
      postgres_version:
        description: 'PostgreSQL version'
        required: false
        type: string
        default: '15'
      redis_version:
        description: 'Redis version'
        required: false
        type: string
        default: '7'
      database_names:
        description: 'Comma-separated list of database names to create'
        required: true
        type: string
    secrets:
      AWS_ROLE_ARN:
        required: true
      CLOUDFLARE_API_TOKEN:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  setup-database:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ vars.AWS_REGION }}
        role-session-name: GitHubActions-Database-Setup

    - name: Get database instance
      id: get-db
      run: |
        echo "Getting database instance for ${{ inputs.cluster_name }}"
        
        DB_INSTANCE_ID=$(aws ec2 describe-instances \
          --filters \
            "Name=tag:Project,Values=${{ vars.PROJECT_NAME }}" \
            "Name=tag:Role,Values=db" \
            "Name=tag:Env,Values=${{ vars.SPOKE_ENV }}" \
            "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        
        if [ "$DB_INSTANCE_ID" == "None" ] || [ -z "$DB_INSTANCE_ID" ]; then
          echo "Error: No database instance found"
          exit 1
        fi
        
        echo "instance_id=$DB_INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "Database Instance: $DB_INSTANCE_ID"
    - name: Mount EBS volume
      run: |
        echo "Mounting EBS volume..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "echo \"Checking mount status...\"",
            "if mountpoint -q /mnt/data; then echo \"Volume already mounted at /mnt/data\"; df -h /mnt/data; exit 0; fi",
            "echo \"Finding EBS volume...\"",
            "lsblk -o NAME,SIZE,TYPE | grep disk",
            "DEVICE=$(lsblk -o NAME,SIZE,TYPE -n | grep disk | awk '\\$2 ~ /50G/ {print \"/dev/\" \\$1}' | head -1)",
            "if [ -z \"$DEVICE\" ]; then echo \"Error: Additional EBS volume not found\"; lsblk; exit 1; fi",
            "echo \"Found EBS device: $DEVICE\"",
            "echo \"Checking if device has filesystem...\"",
            "if ! blkid $DEVICE; then echo \"Creating filesystem on $DEVICE\"; mkfs.ext4 -F $DEVICE; fi",
            "echo \"Creating mount point...\"",
            "mkdir -p /mnt/data",
            "echo \"Mounting $DEVICE to /mnt/data\"",
            "mount $DEVICE /mnt/data",
            "echo \"Adding to fstab for persistence...\"",
            "UUID=$(blkid -s UUID -o value $DEVICE)",
            "grep -q \"$UUID\" /etc/fstab || echo \"UUID=$UUID /mnt/data ext4 defaults,nofail 0 2\" >> /etc/fstab",
            "echo \"Creating directory structure...\"",
            "mkdir -p /mnt/data/postgresql /mnt/data/redis /mnt/data/backups",
            "chown -R root:root /mnt/data",
            "chmod 755 /mnt/data",
            "echo \"Mount completed successfully:\"",
            "df -h /mnt/data",
            "ls -la /mnt/data"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        echo "Waiting for volume mount..."
        
        for i in {1..30}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.get-db.outputs.instance_id }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" == "Success" ]; then
            echo "Volume mounted successfully"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'StandardOutputContent' \
              --output text
            break
          elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
            echo "Volume mount failed"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
          
          echo "Status: $STATUS ($i/30)"
          sleep 5
        done

    - name: Install PostgreSQL ${{ inputs.postgres_version }}
      run: |
        echo "Installing PostgreSQL ${{ inputs.postgres_version }}..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "if dpkg -l | grep -q postgresql-${{ inputs.postgres_version }}; then echo \"PostgreSQL already installed\"; exit 0; fi",
            "apt update",
            "apt install -y wget ca-certificates pwgen",
            "wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add -",
            "echo \"deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\" > /etc/apt/sources.list.d/pgdg.list",
            "apt update",
            "apt install -y postgresql-${{ inputs.postgres_version }} postgresql-contrib-${{ inputs.postgres_version }}",
            "systemctl stop postgresql",
            "if [ ! -d /mnt/data/postgresql/${{ inputs.postgres_version }} ]; then",
            "  mkdir -p /mnt/data/postgresql/${{ inputs.postgres_version }}",
            "  if [ -d /var/lib/postgresql/${{ inputs.postgres_version }}/main ] && [ \"$(ls -A /var/lib/postgresql/${{ inputs.postgres_version }}/main)\" ]; then",
            "    cp -a /var/lib/postgresql/${{ inputs.postgres_version }}/main /mnt/data/postgresql/${{ inputs.postgres_version }}/",
            "  fi",
            "  chown -R postgres:postgres /mnt/data/postgresql",
            "fi",
            "sed -i \"s|data_directory = .*|data_directory = '\''/mnt/data/postgresql/${{ inputs.postgres_version }}/main'\''|\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf",
            "systemctl enable postgresql",
            "systemctl start postgresql"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        echo "Waiting for PostgreSQL installation..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.get-db.outputs.instance_id }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" == "Success" ]; then
            echo "PostgreSQL installed"
            break
          elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
            echo "PostgreSQL installation failed"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
          
          echo "Status: $STATUS ($i/60)"
          sleep 5
        done
    - name: Check existing databases and generate credentials
      id: create-dbs
      run: |
        echo "Checking existing databases and generating credentials if needed..."
        
        # Convert comma-separated database names to array
        IFS=',' read -ra DB_NAMES <<< "${{ inputs.database_names }}"
        
        # Check which databases already exist
        EXISTING_DBS=$(aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["sudo -u postgres psql -t -c \"SELECT datname FROM pg_database WHERE datname NOT IN ('"'"'postgres'"'"', '"'"'template0'"'"', '"'"'template1'"'"');\""]' \
          --output text \
          --query "Command.CommandId")
        
        # Wait for command and get results
        sleep 5
        EXISTING_DB_LIST=$(aws ssm get-command-invocation \
          --command-id $EXISTING_DBS \
          --instance-id ${{ steps.get-db.outputs.instance_id }} \
          --query 'StandardOutputContent' \
          --output text | tr -d ' ')
        
        echo "Existing databases: $EXISTING_DB_LIST"
        
        # Generate credentials for databases that don't exist
        DB_CREDENTIALS=""
        DATABASES_TO_CREATE=""
        SKIP_DB_CREATION=true
        
        for db_name in "${DB_NAMES[@]}"; do
          if echo "$EXISTING_DB_LIST" | grep -q "^${db_name}$"; then
            echo "Database ${db_name} already exists - skipping"
          else
            echo "Database ${db_name} needs to be created"
            SKIP_DB_CREATION=false
            
            # Generate random username and password
            username=$(echo "${db_name}_$(openssl rand -hex 4)" | tr '[:upper:]' '[:lower:]')
            password=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
            
            DB_CREDENTIALS="${DB_CREDENTIALS}${db_name}:${username}:${password},"
            DATABASES_TO_CREATE="${DATABASES_TO_CREATE}${db_name},"
            echo "Generated credentials for ${db_name}"
          fi
        done
        
        # Remove trailing commas
        DB_CREDENTIALS=${DB_CREDENTIALS%,}
        DATABASES_TO_CREATE=${DATABASES_TO_CREATE%,}
        
        echo "db_credentials=$DB_CREDENTIALS" >> $GITHUB_OUTPUT
        echo "databases_to_create=$DATABASES_TO_CREATE" >> $GITHUB_OUTPUT
        echo "skip_db_creation=$SKIP_DB_CREATION" >> $GITHUB_OUTPUT
        
        if [ "$SKIP_DB_CREATION" = "true" ]; then
          echo "All databases already exist - skipping database creation"
        else
          echo "Will create databases: $DATABASES_TO_CREATE"
        fi

    - name: Create new databases
      if: steps.create-dbs.outputs.skip_db_creation == 'false'
      run: |
        echo "Creating new databases..."
        
        # Convert databases to create into array
        IFS=',' read -ra DBS_TO_CREATE <<< "${{ steps.create-dbs.outputs.databases_to_create }}"
        IFS=',' read -ra CREDS <<< "${{ steps.create-dbs.outputs.db_credentials }}"
        
        for cred in "${CREDS[@]}"; do
          IFS=':' read -ra PARTS <<< "$cred"
          db_name="${PARTS[0]}"
          username="${PARTS[1]}"
          password="${PARTS[2]}"
          
          echo "Creating database: ${db_name}"
          
          aws ssm send-command \
            --instance-ids ${{ steps.get-db.outputs.instance_id }} \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"sudo -u postgres createdb ${db_name}\",
              \"sudo -u postgres psql -c \\\"CREATE USER ${username} WITH PASSWORD '${password}';\\\"\",
              \"sudo -u postgres psql -c \\\"GRANT ALL PRIVILEGES ON DATABASE ${db_name} TO ${username};\\\"\",
              \"sudo -u postgres psql -d ${db_name} -c \\\"GRANT ALL ON SCHEMA public TO ${username};\\\"\",
              \"sudo -u postgres psql -d ${db_name} -c \\\"GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO ${username};\\\"\",
              \"sudo -u postgres psql -d ${db_name} -c \\\"GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO ${username};\\\"\",
              \"sudo -u postgres psql -d ${db_name} -c \\\"ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO ${username};\\\"\",
              \"sudo -u postgres psql -d ${db_name} -c \\\"ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO ${username};\\\"\",
              \"echo 'Created database ${db_name}'\"
            ]" \
            --output text \
            --query "Command.CommandId" > /tmp/cmd_${db_name}.txt
          
          COMMAND_ID=$(cat /tmp/cmd_${db_name}.txt)
          
          # Wait for this database creation to complete
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" == "Success" ]; then
              echo "✅ Database ${db_name} created successfully"
              break
            elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
              echo "❌ Database ${db_name} creation failed"
              aws ssm get-command-invocation \
                --command-id $COMMAND_ID \
                --instance-id ${{ steps.get-db.outputs.instance_id }} \
                --query 'StandardErrorContent' \
                --output text
              exit 1
            fi
            
            echo "Status for ${db_name}: $STATUS ($i/30)"
            sleep 2
          done
        done
        
        echo "All new databases created successfully"
    - name: Configure PostgreSQL
      run: |
        echo "Configuring PostgreSQL..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "grep -q \"listen_addresses = .*\\*\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf || sed -i \"s/#listen_addresses = '\''localhost'\''/listen_addresses = '\''*'\''/\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf",
            "grep -q \"host all all 10.0.0.0/8\" /etc/postgresql/${{ inputs.postgres_version }}/main/pg_hba.conf || echo \"host all all 10.0.0.0/8 scram-sha-256\" >> /etc/postgresql/${{ inputs.postgres_version }}/main/pg_hba.conf",
            "systemctl restart postgresql"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "PostgreSQL configured"

    - name: Install Redis ${{ inputs.redis_version }}
      run: |
        echo "Installing Redis ${{ inputs.redis_version }}..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "if systemctl is-active --quiet redis-server; then echo \"Redis already installed\"; exit 0; fi",
            "apt install -y lsb-release curl gpg",
            "curl -fsSL https://packages.redis.io/gpg | gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg",
            "echo \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | tee /etc/apt/sources.list.d/redis.list",
            "apt update",
            "apt install -y redis-server",
            "systemctl stop redis-server",
            "mkdir -p /mnt/data/redis",
            "chown redis:redis /mnt/data/redis",
            "sed -i \"s|^dir .*|dir /mnt/data/redis|\" /etc/redis/redis.conf",
            "systemctl enable redis-server",
            "systemctl start redis-server"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        echo "Waiting for Redis installation..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.get-db.outputs.instance_id }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" == "Success" ]; then
            echo "Redis installed"
            break
          elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
            echo "Redis installation failed"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
          
          echo "Status: $STATUS ($i/60)"
          sleep 5
        done

    - name: Install Certbot and obtain TLS certificate
      run: |
        echo "Installing Certbot and obtaining TLS certificate..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands='[
            "apt install -y certbot python3-certbot-dns-cloudflare",
            "if [ -d /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }} ]; then echo \"Certificate exists\"; exit 0; fi",
            "mkdir -p /root/.secrets",
            "echo \"dns_cloudflare_email = ${{ vars.CERT_EMAIL }}\" > /root/.secrets/cloudflare.ini",
            "echo \"dns_cloudflare_api_key = ${{ secrets.CLOUDFLARE_API_TOKEN }}\" >> /root/.secrets/cloudflare.ini",
            "chmod 600 /root/.secrets/cloudflare.ini",
            "certbot certonly --dns-cloudflare --dns-cloudflare-credentials /root/.secrets/cloudflare.ini -d ${{ vars.DB_PRIVATE_DNS }} --non-interactive --agree-tos --email ${{ vars.CERT_EMAIL }} --dns-cloudflare-propagation-seconds 30"
          ]' \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        echo "Waiting for certificate..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.get-db.outputs.instance_id }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" == "Success" ]; then
            echo "Certificate obtained"
            break
          elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
            echo "Certificate acquisition failed"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ steps.get-db.outputs.instance_id }} \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi
          
          echo "Status: $STATUS ($i/60)"
          sleep 5
        done
    - name: Configure PostgreSQL and Redis TLS
      run: |
        echo "Configuring TLS for PostgreSQL and Redis..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands="[
            \"# Configure PostgreSQL TLS\",
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/fullchain.pem /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.crt\",
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/privkey.pem /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key\",
            \"chown postgres:postgres /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.*\",
            \"chmod 600 /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key\",
            \"grep -q '^ssl = on' /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf || sed -i 's/#ssl = off/ssl = on/' /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf\",
            \"grep -q \\\"ssl_cert_file = '/var/lib/postgresql/${{ inputs.postgres_version }}/main/server.crt'\\\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf || sed -i \\\"s|#ssl_cert_file = 'server.crt'|ssl_cert_file = '/var/lib/postgresql/${{ inputs.postgres_version }}/main/server.crt'|\\\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf\",
            \"grep -q \\\"ssl_key_file = '/var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key'\\\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf || sed -i \\\"s|#ssl_key_file = 'server.key'|ssl_key_file = '/var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key'|\\\" /etc/postgresql/${{ inputs.postgres_version }}/main/postgresql.conf\",
            \"# Configure Redis TLS\",
            \"mkdir -p /etc/redis/certs\",
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/fullchain.pem /etc/redis/certs/server.crt\",
            \"cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/privkey.pem /etc/redis/certs/server.key\",
            \"chown redis:redis /etc/redis/certs/*\",
            \"chmod 600 /etc/redis/certs/server.key\",
            \"grep -q '^port 0' /etc/redis/redis.conf || sed -i 's/^port 6379/port 0/' /etc/redis/redis.conf\",
            \"grep -q '^tls-port' /etc/redis/redis.conf || echo 'tls-port 6379' >> /etc/redis/redis.conf\",
            \"grep -q '^tls-cert-file' /etc/redis/redis.conf || echo 'tls-cert-file /etc/redis/certs/server.crt' >> /etc/redis/redis.conf\",
            \"grep -q '^tls-key-file' /etc/redis/redis.conf || echo 'tls-key-file /etc/redis/certs/server.key' >> /etc/redis/redis.conf\",
            \"grep -q '^tls-ca-cert-file' /etc/redis/redis.conf || echo 'tls-ca-cert-file /etc/redis/certs/server.crt' >> /etc/redis/redis.conf\",
            \"grep -q '^tls-auth-clients no' /etc/redis/redis.conf || echo 'tls-auth-clients no' >> /etc/redis/redis.conf\",
            \"# Restart services\",
            \"systemctl restart postgresql\",
            \"systemctl restart redis-server\"
          ]" \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "TLS configured for PostgreSQL and Redis"

    - name: Store database connection strings in AWS Secrets Manager
      if: steps.create-dbs.outputs.skip_db_creation == 'false'
      run: |
        echo "Storing database connection strings in AWS Secrets Manager..."
        
        # Parse database credentials for newly created databases
        IFS=',' read -ra CREDS <<< "${{ steps.create-dbs.outputs.db_credentials }}"
        
        # Create connection strings for each new database
        for cred in "${CREDS[@]}"; do
          IFS=':' read -ra PARTS <<< "$cred"
          db_name="${PARTS[0]}"
          username="${PARTS[1]}"
          password="${PARTS[2]}"
          
          # PostgreSQL connection string with TLS
          pg_connection_string="postgresql://${username}:${password}@${{ vars.DB_PRIVATE_DNS }}:5432/${db_name}?sslmode=require"
          
          # Secret name format: fitsync/{environment}/{service}-db-url
          secret_name="${{ vars.PROJECT_NAME }}/${{ inputs.environment }}/${db_name}-db-url"
          
          echo "Creating secret: $secret_name"
          
          # Create secret (will fail if exists, which is fine)
          aws secretsmanager create-secret \
            --name "$secret_name" \
            --description "Database connection string for ${db_name} in ${{ inputs.environment }}" \
            --secret-string "$pg_connection_string" \
            --tags '[{"Key":"Project","Value":"${{ vars.PROJECT_NAME }}"},{"Key":"Environment","Value":"${{ inputs.environment }}"},{"Key":"Service","Value":"'${db_name}'"}]' \
            2>/dev/null && echo "✅ Created secret for ${db_name}: $secret_name" || echo "ℹ️  Secret for ${db_name} may already exist"
        done
        
        # Create Redis connection string (only if not exists)
        redis_connection_string="redis://${{ vars.DB_PRIVATE_DNS }}:6379?tls=true"
        redis_secret_name="${{ vars.PROJECT_NAME }}/${{ inputs.environment }}/redis-url"
        
        echo "Creating Redis secret: $redis_secret_name"
        
        aws secretsmanager create-secret \
          --name "$redis_secret_name" \
          --description "Redis connection string for ${{ inputs.environment }}" \
          --secret-string "$redis_connection_string" \
          --tags '[{"Key":"Project","Value":"${{ vars.PROJECT_NAME }}"},{"Key":"Environment","Value":"${{ inputs.environment }}"},{"Key":"Service","Value":"redis"}]' \
          2>/dev/null && echo "✅ Created Redis secret: $redis_secret_name" || echo "ℹ️  Redis secret may already exist"

    - name: Check existing secrets status
      if: steps.create-dbs.outputs.skip_db_creation == 'true'
      run: |
        echo "All databases already exist - checking if secrets are also present..."
        
        # Convert comma-separated database names to array
        IFS=',' read -ra DB_NAMES <<< "${{ inputs.database_names }}"
        
        # Check each database secret
        for db_name in "${DB_NAMES[@]}"; do
          secret_name="${{ vars.PROJECT_NAME }}/${{ inputs.environment }}/${db_name}-db-url"
          
          if aws secretsmanager describe-secret --secret-id "$secret_name" >/dev/null 2>&1; then
            echo "✅ Secret exists for ${db_name}: $secret_name"
          else
            echo "⚠️  Secret missing for ${db_name}: $secret_name"
          fi
        done
        
        # Check Redis secret
        redis_secret_name="${{ vars.PROJECT_NAME }}/${{ inputs.environment }}/redis-url"
        if aws secretsmanager describe-secret --secret-id "$redis_secret_name" >/dev/null 2>&1; then
          echo "✅ Redis secret exists: $redis_secret_name"
        else
          echo "⚠️  Redis secret missing: $redis_secret_name"
        fi

    - name: Setup certificate auto-renewal
      run: |
        echo "Setting up auto-renewal..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands="[
            \"mkdir -p /etc/letsencrypt/renewal-hooks/deploy\",
            \"if [ -f /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh ]; then exit 0; fi\",
            \"echo '#!/bin/bash' > /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/fullchain.pem /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.crt' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/privkey.pem /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'chown postgres:postgres /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.*' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'chmod 600 /var/lib/postgresql/${{ inputs.postgres_version }}/main/server.key' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/fullchain.pem /etc/redis/certs/server.crt' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'cp /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/privkey.pem /etc/redis/certs/server.key' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'chown redis:redis /etc/redis/certs/*' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'chmod 600 /etc/redis/certs/server.key' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'systemctl restart postgresql' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"echo 'systemctl restart redis-server' >> /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\",
            \"chmod +x /etc/letsencrypt/renewal-hooks/deploy/restart-services.sh\"
          ]" \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }}
        echo "Auto-renewal configured"
    - name: Verify database setup
      run: |
        echo "Verifying database setup..."
        
        aws ssm send-command \
          --instance-ids ${{ steps.get-db.outputs.instance_id }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands="[
            \"echo '=== PostgreSQL Status ==='\",
            \"systemctl status postgresql --no-pager || true\",
            \"sudo -u postgres psql -c 'SELECT version();' || true\",
            \"sudo -u postgres psql -c 'SHOW ssl;' || true\",
            \"sudo -u postgres psql -c '\\\\l' || true\",
            \"echo '=== Redis Status ==='\",
            \"systemctl status redis-server --no-pager || true\",
            \"redis-cli --tls --cacert /etc/ssl/certs/ca-certificates.crt ping || true\",
            \"echo '=== Port Status ==='\",
            \"ss -tlnp | grep -E ':(5432|6379)' || true\",
            \"echo '=== Certificate Status ==='\",
            \"ls -la /etc/letsencrypt/live/${{ vars.DB_PRIVATE_DNS }}/ || true\"
          ]" \
          --output text \
          --query "Command.CommandId" > /tmp/cmd_id.txt
        
        COMMAND_ID=$(cat /tmp/cmd_id.txt)
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.get-db.outputs.instance_id }} || true
        
        echo "Verification output:"
        aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ steps.get-db.outputs.instance_id }} \
          --query 'StandardOutputContent' \
          --output text || echo "Could not retrieve output"

    - name: Summary
      run: |
        echo "=========================================="
        echo "Enhanced Database Setup Complete!"
        echo "=========================================="
        echo "PostgreSQL: ${{ inputs.postgres_version }}"
        echo "Redis: ${{ inputs.redis_version }}"
        echo "Database DNS: ${{ vars.DB_PRIVATE_DNS }}"
        echo "TLS: Enabled"
        echo "Data Directory: /mnt/data"
        echo ""
        echo "Requested databases:"
        IFS=',' read -ra DB_NAMES <<< "${{ inputs.database_names }}"
        for db_name in "${DB_NAMES[@]}"; do
          echo "  - ${db_name}"
        done
        echo ""
        if [ "${{ steps.create-dbs.outputs.skip_db_creation }}" = "true" ]; then
          echo "Status: All databases already existed - no new databases created"
          echo "Action: Verified existing database and secret configuration"
        else
          echo "Status: Created new databases and stored credentials"
          echo "New databases: ${{ steps.create-dbs.outputs.databases_to_create }}"
        fi
        echo ""
        echo "Secrets stored in AWS Secrets Manager:"
        echo "  Pattern: ${{ vars.PROJECT_NAME }}/${{ inputs.environment }}/{service}-db-url"
        echo "  Redis: ${{ vars.PROJECT_NAME }}/${{ inputs.environment }}/redis-url"
        echo ""
        echo "Connection format:"
        echo "  PostgreSQL: postgresql://user:pass@${{ vars.DB_PRIVATE_DNS }}:5432/dbname?sslmode=require"
        echo "  Redis: redis://${{ vars.DB_PRIVATE_DNS }}:6379?tls=true"
        echo "=========================================="
